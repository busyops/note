# 一、列表

列表（list） 是一种用于存储**一组有序的元素**的数据结构，可以存放任意类型的对象，比如数字、字符串、甚至其他列表。

## 1. 特点

- 有序：列表中的元素是按照插入顺序排列的，每个元素都有唯一的**索引**（从 0 开始），可以通过索引访问或修改某个位置的值。

- 可变：列表创建后，可以修改它的内容，包括添加、删除、修改元素。

- 支持重复元素：列表中可以包含重复的值，Python 不会自动去重。

- 元素类型不受限制：一个列表可以包含不同类型的数据，比如整数、字符串、布尔值、甚至其他列表。



## 2. 定义方式

 - 使用方括号 `[]`

```python
empty_list = []   # 空列表
-----含有元素的列表------------
numbers = [1, 2, 3, 4]
fruits = ["apple", "banana", "cherry"]
mixed = [1, "hello", True, 3.14]
```



- 使用 `list()` 函数

```python
a = list()  # 空列表
-------
# 从其他可迭代对象创建列表
b = list("hello")       # ['h', 'e', 'l', 'l', 'o']
c = list((1, 2, 3))      # [1, 2, 3]，元组转列表
```



##  3. 常见的列表方法

| 方法                     | 作用             | 示例               | 说明                                  |
| ------------------------ | ---------------- | ------------------ | ------------------------------------- |
| `append(x)`              | 添加元素到末尾   | `a.append(10)`     | 列表末尾增加一个元素                  |
| `extend(iterable)`       | 扩展列表         | `a.extend([4, 5])` | 把另一个可迭代对象的元素加到列表末尾  |
| `insert(i, x)`           | 插入元素         | `a.insert(1, 100)` | 在索引 i 位置插入元素 x               |
| `remove(x)`              | 删除元素         | `a.remove(3)`      | 删除列表中第一个值为 x 的元素         |
| `pop([i])`               | 弹出元素         | `a.pop(2)`         | 删除并返回索引 i 处的元素（默认最后） |
| `clear()`                | 清空列表         | `a.clear()`        | 删除所有元素                          |
| `index(x[,start[,end]])` | 查找索引         | `a.index(2)`       | 返回元素 x 第一次出现的索引           |
| `count(x)`               | 计数元素出现次数 | `a.count(2)`       | 返回元素 x 在列表中出现的次数         |
| `sort()`                 | 排序             | `a.sort()`         | 原地升序排序                          |
| `reverse()`              | 反转顺序         | `a.reverse()`      | 原地反转列表                          |
| `copy()`                 | 复制列表         | `b = a.copy()`     | 返回列表的浅拷贝                      |



# 二、元祖

元组是有序、不可变的元素集合。用圆括号 `()` 表示。

## 1. 特点

| 特点       | 说明                             |
| ---------- | -------------------------------- |
| 有序       | 元素有固定的顺序                 |
| 不可变     | 创建后不能修改其内容             |
| 可存重复值 | 可以包含重复的元素               |
| 可嵌套     | 元组内可以嵌套列表、字典、元组等 |



## 2. 定义方式

```
t1 = ()
t1 = (1, 2, 3)          # 普通元组
t2 = (1,)               # 单个元素的元组，必须带逗号
t3 = tuple([1, 2, 3])   # 使用 tuple() 函数
```



## 3. 常见的元组方法

元祖常见的方法和列表一样，但是只要涉及修改的方法，都是不可用的。

```
t = (1, 2, 3)
t[0] = 100  # ❌ 错误，元组不能修改
```

注意：元组不可变，但如果元组中包含可变对象（如列表），其内容是可以变的：

```
t = ([1, 2], 3)
t[0].append(99)     # ✅ 这是允许的
print(t)            # 输出 ([1, 2, 99], 3)
```



| 操作     | 示例          | 说明                 |
| -------- | ------------- | -------------------- |
| 访问元素 | `t[0]`        | 索引从 0 开始        |
| 切片     | `t[1:3]`      | 取一部分元素         |
| 遍历     | `for x in t:` | 依次访问元素         |
| 连接元组 | `t1 + t2`     | 合并新元组           |
| 乘法重复 | `t * 3`       | 元素重复三次         |
| 成员判断 | `3 in t`      | 判断元素是否存在     |
| 获取长度 | `len(t)`      | 返回元素数量         |
| 转列表   | `list(t)`     | 元组转列表（可修改） |

```python
t = (1, 2, 3)
```



# 三、字符串

字符串（String）是 Python 中用于表示文本的数据类型，简单来说，字符串就是由一串字符组成的内容，比如：

```python
"hello"
'Python'
"12345"
"你好，世界"
```

## 1. 定义方式

```
s1 = 'hello'
s2 = "world"
s3 = '''多行
字符串'''
```

## 2. 字符串拼接

```
a = 'hello'
b = 'world'
print(a + ' ' + b)  # hello world
```

⚠️ 注意：`+` 会创建新字符串，频繁拼接建议用 join



## 3. 常见内置方法汇总

- 基本判断类方法

| 方法          | 说明               | 示例                 | 结果   |
| ------------- | ------------------ | -------------------- | ------ |
| `s.isdigit()` | 是否全为数字       | `"123".isdigit()`    | `True` |
| `s.isalpha()` | 是否全为字母       | `"abc".isalpha()`    | `True` |
| `s.isalnum()` | 是否全为字母或数字 | `"abc123".isalnum()` | `True` |
| `s.isspace()` | 是否全为空白字符   | `" \t\n".isspace()`  | `True` |
| `s.islower()` | 是否全为小写字母   | `"hello".islower()`  | `True` |
| `s.isupper()` | 是否全为大写字母   | `"HELLO".isupper()`  | `True` |

- 大小写转换

| 方法             | 说明                 | 示例                         | 结果            |
| ---------------- | -------------------- | ---------------------------- | --------------- |
| `s.lower()`      | 全部转为小写         | `"Hello".lower()`            | `"hello"`       |
| `s.upper()`      | 全部转为大写         | `"Hello".upper()`            | `"HELLO"`       |
| `s.capitalize()` | 首字母大写，其余小写 | `"hello world".capitalize()` | `"Hello world"` |
| `s.title()`      | 所有单词首字母大写   | `"hello world".title()`      | `"Hello World"` |
| `s.swapcase()`   | 大小写互换           | `"AbC".swapcase()`           | `"aBc"`         |



- 查找与定位

| 方法                 | 说明                                | 示例                        | 结果   |
| -------------------- | ----------------------------------- | --------------------------- | ------ |
| `s.find('a')`        | 返回首次出现的位置，找不到返回 `-1` | `"banana".find('a')`        | `1`    |
| `s.rfind('a')`       | 返回最后一次出现的位置              | `"banana".rfind('a')`       | `5`    |
| `s.index('a')`       | 同 `find()`，但找不到会报错         | `"banana".index('a')`       | `1`    |
| `s.rindex('a')`      | 同 `rfind()`，找不到报错            | `"banana".rindex('a')`      | `5`    |
| `s.startswith('ba')` | 是否以指定子串开头                  | `"banana".startswith('ba')` | `True` |
| `s.endswith('na')`   | 是否以指定子串结尾                  | `"banana".endswith('na')`   | `True` |



- 替换与分割

| 方法                  | 说明                       | 示例                        | 结果                 |
| --------------------- | -------------------------- | --------------------------- | -------------------- |
| `s.replace('a', 'o')` | 替换所有 `'a'` 为 `'o'`    | `"banana".replace('a','o')` | `"bonono"`           |
| `s.split(',')`        | 拆分为列表                 | `"a,b,c".split(',')`        | `['a', 'b', 'c']`    |
| `s.rsplit(',', 1)`    | 从右拆分一次               | `"a,b,c".rsplit(',', 1)`    | `['a,b', 'c']`       |
| `s.partition('a')`    | 拆成三部分：前、分隔符、后 | `"banana".partition('a')`   | `('b', 'a', 'nana')` |
| `s.rpartition('a')`   | 从右拆分成三部分           | `"banana".rpartition('a')`  | `('banan', 'a', '')` |



- 去除空白

| 方法         | 说明             | 示例                  | 结果      |
| ------------ | ---------------- | --------------------- | --------- |
| `s.strip()`  | 去除首尾空白字符 | `"  hello  ".strip()` | `"hello"` |
| `s.lstrip()` | 去除左侧空白字符 | `"  hello".lstrip()`  | `"hello"` |
| `s.rstrip()` | 去除右侧空白字符 | `"hello  ".rstrip()`  | `"hello"` |



- 对齐操作

| 方法                | 说明                        | 示例                   | 结果           |
| ------------------- | --------------------------- | ---------------------- | -------------- |
| `s.center(10, '*')` | 居中并用 `*` 填充至 10 长度 | `"hi".center(10, '*')` | `"****hi****"` |
| `s.ljust(10, '-')`  | 左对齐并填充                | `"hi".ljust(10, '-')`  | `"hi--------"` |
| `s.rjust(10, '.')`  | 右对齐并填充                | `"hi".rjust(10, '.')`  | `"........hi"` |
| `s.zfill(5)`        | 左侧补零至指定长度          | `"42".zfill(5)`        | `"00042"`      |



- 连接字符串

| 方法              | 说明             | 示例                        | 结果      |
| ----------------- | ---------------- | --------------------------- | --------- |
| `'sep'.join(seq)` | 用指定分隔符连接 | `'-'.join(['a', 'b', 'c'])` | `"a-b-c"` |

## 4. 字符串格式化

Python 提供多种方式进行字符串格式化。

### (1) `%` 运算符（旧式写法）

```python
name = "Alice"
age = 25
height = 1.735
print("姓名：%s, 年龄：%d, 身高：%.2f 米" % (name, age, height))
# 姓名：Alice, 年龄：25, 身高：1.73 米
```

常用格式符：

| 格式符  | 说明                  |
| ------- | --------------------- |
| `%s`    | 字符串                |
| `%d`    | 十进制整数            |
| `%f`    | 浮点数（默认6位小数） |
| `%.2f`  | 浮点数（保留2位小数） |
| `%x/%X` | 十六进制              |

### (2) `str.format()` 方法

```python
name = "Bob"
age = 30
print("姓名：{}, 年龄：{}".format(name, age))           # 自动编号
print("姓名：{0}, 年龄：{1}".format(name, age))         # 显式编号
print("金额：{:,.2f}".format(1234567.891))              # 千分位 + 2位小数
```

**占位符用法：**
- `{}`：自动按顺序取 `.format()` 参数  
- `{0}`：按位置取值（从 0 开始）  
- `{name}`：按关键字取值  

**常见格式控制（`{:<格式说明>}`）：**

| 语法      | 说明             | 示例                         | 结果        |
| --------- | ---------------- | ---------------------------- | ----------- |
| `.nf`     | 保留 n 位小数    | `"{:.2f}".format(3.14159)`   | `3.14`      |
| `>n`      | 右对齐，总宽度 n | `"{:>5}".format("hi")`       | `"   hi"`   |
| `<n`      | 左对齐，总宽度 n | `"{:<5}".format("hi")`       | `"hi   "`   |
| `^n`      | 居中，总宽度 n   | `"{:^5}".format("hi")`       | `" hi  "`   |
| `,`       | 千分位分隔       | `"{:,}".format(1234567)`     | `1,234,567` |
| 填充+对齐 | 指定填充符并对齐 | `"{:#^7}".format("hi")`      | `"##hi###"` |
| 进制      | 二/八/十六进制   | `"{:b}".format(10)` → `1010` |             |

**复杂示例：**

```python
print("{1}*{0}={2:0>3}".format(5, 6, 5*6))   # 6*5=030
print("{}*{}={:#<3}".format(4, 5, 20))       # 4*5=20#
print("{:#^7}".format('*' * 3))              # ##***##
```
说明：
- `{index}`：按位置取值
- `{value:填充符对齐宽度}`：控制对齐和填充
- `0>3`：右对齐宽 3，左侧填 0
- `#<3`：左对齐宽 3，右侧填 `#`
- `#^7`：居中宽 7，两侧填 `#`

### (3) **f-string**

```python
name = "Carol"
age = 28
height = 1.68
print(f"姓名：{name}, 年龄：{age}, 身高：{height:.2f} 米")
print(f"2 + 3 = {2 + 3}")
```

# 四、字节串
## 1. 编码

编码（Encoding）就是把信息（文字、符号等）转换成计算机可以理解和存储的数字形式的过程。计算机底层只能处理 二进制（0 和 1），而人类使用的语言是各种文字（中文、英文、日文、符号、表情…）。编码就是定义一个“映射关系”：

- 哪个字符 → 对应哪个数字（再存成二进制）。

- 例如在 ASCII 编码中：

```python
'A' → 65 → 01000001
'B' → 66 → 01000010
```

> 就像电话本，把“张三”映射到电话号码“138xxxx8888”，电脑用的是“字符表”把字符映射到数字。

### (1) 为什么需要编码

如果不编码，计算机无法知道你输入的“字母 A”在内存里该用什么样的 0/1 来表示。
 编码的作用主要有几个方面：
**计算机存储和处理需要统一标准**

- 没有编码，计算机看到的只是二进制的 0 和 1，无法区分是文字还是图片。
- 有了编码，电脑可以知道：这个二进制数据代表的是什么字符。

**不同语言的文字数量差异**

- 英文 26 个字母，用 1 个字节就够（ASCII）。
- 中文有几万个汉字，需要 2～4 个字节（GBK、UTF-8 等）。
- 编码方案决定了每个字符用几个字节、怎么排列。

**跨平台、跨系统的兼容**

- 如果没有统一的编码规则，不同系统保存的文件可能互相打不开（产生乱码）。
- 例如 Windows 默认 `GBK`，Linux 默认 `UTF-8`，编码不一致时就会乱码。

**支持全球化**

- 早期的 ASCII 只能表示英文。
- Unicode 系列（UTF-8、UTF-16、UTF-32）可以表示全世界所有文字和符号，包括 emoji。

**举个乱码的例子**
假设一个中文“你”在 UTF-8 中是 `**0xE4 0xBD 0xA0**`（3 字节），
 但如果用 GBK 编码去解读这 3 个字节，就会变成完全不同的符号，导致乱码。



### (2) 常见的编码方案

| 编码名称                 | 字节长度              | 支持字符范围 / 语言          | 是否兼容 ASCII                                               | 常用场景                         | 备注                     |
| ------------------------ | --------------------- | ---------------------------- | ------------------------------------------------------------ | -------------------------------- | ------------------------ |
| **ASCII**                | 1 字节（7 位有效）    | 英文、数字、基础符号         | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 早期计算机、协议头、基础文本     | 最基础的字符编码标准     |
| **ISO-8859-1 (Latin-1)** | 1 字节                | 西欧语言                     | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 老系统、旧网页                   | Windows-1252 是其超集    |
| **Windows-1252**         | 1 字节                | 西欧语言                     | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | Windows 文本文件、旧网页         | 增加了额外符号           |
| **GB2312**               | 1–2 字节              | 简体中文、英文               | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 老版简体中文文档、早期网页       | 收录 6763 个汉字         |
| **GBK**                  | 1–2 字节              | 简/繁中文、英文              | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | Windows 简体中文系统             | 向下兼容 GB2312          |
| **GB18030**              | 1–4 字节              | Unicode 全部字符             | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 国家标准、现代中文系统           | 中国强制性标准           |
| **BIG5**                 | 1–2 字节              | 繁体中文（台港澳）           | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 台港澳系统、文档                 | 与 GBK 不兼容            |
| **Shift_JIS**            | 1–2 字节              | 日文（平假名、片假名、汉字） | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 日本系统、文档                   | 与 EUC-JP 不兼容         |
| **EUC-KR**               | 1–2 字节              | 韩文、汉字                   | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 韩国系统、网页                   | -                        |
| **UTF-8**                | 1–4 字节              | Unicode 全部字符             | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | HTML、JSON、Linux 系统、网络传输 | 英文 1 字节，中文 3 字节 |
| **UTF-16**               | 2 或 4 字节           | Unicode 全部字符             | ✘（部分）                                                    | Windows 内部编码、Java、C#       | 有字节序（LE/BE）问题    |
| **UTF-32**               | 4 字节                | Unicode 全部字符             | ✘                                                            | 内部字符处理                     | 占用空间大               |
| **Base64**               | 4 字符表示 3 字节数据 | 任意二进制 → 文本            | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | 邮件附件、URL、加密数据传输      | 非字符集，属于编码方式   |
| **URL 编码**             | 可变（%xx 形式）      | 任意字节 → ASCII             | ![:加粗的对钩:](https://a.slack-edge.com/production-standard-emoji-assets/14.0/google-medium/2714-fe0f.png) | HTTP URL、表单数据               | 非字符集                 |

### (3) Ascii 码表
![ascii_table](..\images\ascii_table.png)



## 2. 字节串（bytes 和 bytearray）

在 Python 中，**字符串（`str`）** 是 Unicode 文本，表示人类可读的字符；而 **字节串** 用来存储 **原始的二进制数据**，表示计算机底层的 0/1。字节串有两种类型：**不可变的 `bytes`** 和 **可变的 `bytearray`**。

### (1) bytes 类型

- **定义方式**

  ```python
  b1 = b'hello'                  # 直接写 b 前缀（只能包含 ASCII）
  b2 = b'\xe5\x95\x8a'           # 用十六进制表示原始字节
  b3 = bytes([72, 101, 108])     # 列表转字节串 → b'Hel'
  b4 = "你好".encode("utf-8")     # str → bytes
  b7 = bytes(5)                  # b'\x00\x00\x00\x00\x00'
  b8 = bytes()                   # b'' 
  ```

- **特点**

  - 不可变对象，类似于字符串。
  - 每个元素是 `0~255` 的整数（对应一个字节）。

  ```
  b = b'ABC' 
  print(b[0])     # 65
  print(b[1:])    # b'BC'
  ```

### (2) bytearray 类型

- **定义方式**

  ```python
  ba1 = bytearray(b'hello')                  # bytearray(b'hello')
  ba2 = bytearray(b'\xe5\x95\x8a')           # bytearray(b'\xe5\x95\x8a')
  ba3 = bytearray([72, 101, 108])            # bytearray(b'Hel')
  ba4 = bytearray("你好", "utf-8")            # bytearray(b'\xe4\xbd\xa0\xe5\xa5\xbd')
  ba7 = bytearray(5)                         # bytearray(b'\x00\x00\x00\x00\x00')
  ba8 = bytearray()                          # bytearray(b'')
  ```

- **特点**

  - 可变对象，可以原地修改内容。
  - 支持几乎所有 `bytes` 的方法，但允许修改字节值。

  ```python
  ba = bytearray(b'hello')
  ba[0] = 72         # 把第一个字节改为 72 (ASCII 'H')
  print(ba)          # bytearray(b'Hello')
  ```



# 五、切片（slice）

切片是 Python 对 序列类型（Sequence） 的通用操作，用于从原序列按区间和步长取出子序列。适用于：list、tuple、str、bytes、bytearray 等。

## 1. 基本语法
```python
seq[start : end : step]
```

- `start`：起始索引（含），默认 0
- `end`：结束索引（不含），默认 len(seq)
- `step`：步长，默认 1；可以为负，表示反向

**快速示例**

```python
s = "Python"
s[0:2]     # 'Py'
s[:4]      # 'Pyth'
s[2:]      # 'thon'
s[:]       # 'Python'（浅拷贝）
s[::2]     # 'Pto'
s[::-1]    # 'nohtyP'（反转）
```



## 2. 通用规则与细节

- 支持负索引：-1 表示最后一个元素。

```python
s = "abcdef"
s[-3:]    # 'def'
s[:-2]    # 'abcd'
s[-4:-1]  # 'cde'
```

- 越界安全：切片超出边界不会报错，只会截到可用范围。

```python
s = "abc"
s[-100:100]  # 'abc'
```

- 空结果：当区间方向与步长不一致时，结果为空。

```python
s[3:1]     # ''（step 默认 1，方向相反）
s[3:1:-1]  # 'dc'（指定负步长即可）
```

- 浅拷贝：seq[:] 返回同类型的新对象（浅拷贝）。

- 步长为 0 不允许：seq[::0] 会报错。

## 3. 针对不同序列的示例
- 列表 list
```python
lst = [10, 20, 30, 40, 50]
lst[1:4]     # [20, 30, 40]
lst[::-1]    # [50, 40, 30, 20, 10]
```

- 元组 tuple

```python
t = (1, 2, 3, 4)
t[::2]       # (1, 3)
```

- 字符串 str

```python
s = "hello world"
s[6:]        # 'world'
s[::3]       # 'hlwl'
```

- 字节串 bytes

```python
b = b'ABCDEF'
b[1:4]       # b'BCD'
b[::-1]      # b'FEDCBA'
```

- 可变字节串 bytearray

```python
ba = bytearray(b'abcdef')
ba[2:5]      # bytearray(b'cde')
```



## 4. 可变序列的切片赋值

切片不仅能“取”，还能“改”（仅可变序列）：

```python
lst = [1, 2, 3, 4, 5]
lst[1:3] = [20, 30]       # [1, 20, 30, 4, 5]
lst[::2] = [9, 8, 7]      # [9, 20, 8, 4, 7] ；数量必须匹配步长结果长度
lst[1:3] = [20]           # [1, 20, 4, 5]

ba = bytearray(b'abcdef')
ba[0:3] = b'XYZ'          # bytearray(b'XYZdef')
ba[::2] = b'123'          # 必须长度相等
```

> 规则：当使用步长切片赋值（如 `seq[::2] = ...`）时，右侧可迭代对象的长度必须与切片结果长度相同；否则报错。

## 5. slice 对象（面向可读性与复用）

切片表达式等价于使用 slice(start, end, step) 生成的切片对象：

```python
s = "Python"
sl = slice(1, 5, 2)  # 等价于 [1:5:2]
s[sl]                # 'yh'
```


适合在函数参数、复用场景中使用，提高可读性。

## 6. 常见模式与技巧

- 复制/浅拷贝：seq_copy = seq[:]
- 去掉首尾 N 个元素：seq[n:-n]
- 反转序列：seq[::-1]
- 固定间隔抽样：seq[::k]（如每隔 k 取 1）
- 窗口切片（滑动窗口）：

```python
s = "abcdef"
k = 3
windows = [s[i:i+k] for i in range(0, len(s)-k+1)]
s = "abcdef"
# ['abc', 'bcd', 'cde', 'def']
```



## 7. 常见坑位

- end 不包含：seq[0:2] 只到索引 1。

- 步长与方向：seq[3:1] 空，因为默认步长为正；要反向取用 seq[3:1:-1]。
- 不可变序列不能切片赋值：str/tuple/bytes 不能通过切片修改内容。
- 步长赋值长度必须匹配：lst[::2] = [...] 右侧长度需等于切片命中元素个数。
- 大切片的性能：切片会新建对象，超大序列频繁切片可能带来性能/内存压力。

## 8. 进阶：与编码/字节相关的注意

- 对 bytes/bytearray 的切片结果仍为同类型：

```python
b = b'\xe5\x95\x8a'     # UTF-8 中“啊”的三个字节
b[:2]                   # b'\xe5\x95' （注意不要随意截断多字节字符后再 decode）
```

- 不要随意对多字节编码（如 UTF-8）的中间位置切片后解码，可能导致 `UnicodeDecodeError` 或乱码。需要按编码的字节边界处理。




- **字典**（dict）

  ```python
  d = {"name": "Tom", "age": 20}
  print(d["name"])
  ```

- **集合**（set）

  ```python
  s = {1, 2, 3}
  s.add(4)
  ```

