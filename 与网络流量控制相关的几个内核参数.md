### 1. **tcp_syncookies**

启用或禁用 **SYN Cookies**。SYN Cookies 是一种防止 **SYN Flood** 攻击的技术，允许在 TCP 三次握手的初始阶段保护服务器。当启用 SYN Cookies 时，在接收到 SYN 请求并准备建立连接时，系统不会立即为该连接分配资源（如内存）。而是通过一个加密的 Cookie 来响应客户端，只有在握手完成后才会分配资源。这可以防止大量的半连接占用系统资源。

**取值**：

- `0`：禁用 SYN Cookies。

- `1`：启用 SYN Cookies。

- `2`：启用 SYN Cookies，并且在系统受到攻击时自动启用。

**查看当前值**

```shell
~]# sysctl net.ipv4.tcp_syncookies
```

**临时设置值**

```
~]# sysctl -w net.ipv4.tcp_syncookies=1
~]# sysctl -p
```

**永久设置**

编辑`/etc/sysctl.conf`或`/etc/sysctl.d/syn_flood.conf`，加入

```shell
net.ipv4.tcp_syncookies = 1
```

执行命令：`~]# sysctl -p`

**验证设置**

```shell
[root@node1 sysctl.d]# sysctl net.ipv4.tcp_syncookies
net.ipv4.tcp_syncookies = 1
```



---



### 2. **tcp_max_syn_backlog**

设置在三次握手过程中，操作系统保持等待确认的 SYN 请求的最大数量。如果该参数设置过低，可能会导致合法连接无法建立（因为 SYN 队列满了），新的连接请求会被拒绝。默认值根据具体的操作系统和内核版本不同而有所不同，测试使用的debian 12为1024，而设置过高可能会导致资源的浪费或潜在的 DoS 攻击。如接收缓冲区、连接队列长度等设置过高，系统会为每个连接或请求分配大量资源（内存、CPU 时间等）。高设置可能会让系统将更多资源用于处理网络请求，挤压其他服务的资源。在高流量攻击下，尽管系统没有完全崩溃，但正常用户的体验会显著下降，比如延迟增加或请求被拒绝。虽然设置较高的参数值可以在高负载场景下提升系统的处理能力，但如果缺乏其他安全防护措施（如 SYN Cookies、防火墙规则等），攻击者可能利用这些高配置放大攻击的效果。

为此，建议在配置这些参数时找到平衡点，既能满足业务需求，又不过度浪费资源，同时结合其他防护手段（如限制连接速率、启用 SYN Cookies 等）来增强系统的抗攻击能力。

**查看当前值**：

```shell
sysctl net.ipv4.tcp_max_syn_backlog
```

**临时设置值**：

```shell
sysctl -w net.ipv4.tcp_max_syn_backlog=2048
```

**永久设置**

编辑`/etc/sysctl.conf`或`/etc/sysctl.d/syn_flood.conf`，加入

```shell
net.ipv4.tcp_max_syn_backlog = 2048
```

执行命令：`~]# sysctl -p`

**验证设置**

```shell
[root@node1 ~]# sysctl net.ipv4.tcp_max_syn_backlog
net.ipv4.tcp_max_syn_backlog = 1024
```



---



### 3. **tcp_fin_timeout**

该参数定义了 **TCP 连接关闭** 后等待其连接状态变为 **FIN-WAIT-2** 状态的超时时间。对于每个连接，系统会在关闭连接时等待一段时间。通常是 `60` 秒。降低这个超时时间有助于减少资源占用，在高并发的服务器环境中尤其有用。减少 **FIN-WAIT-2** 队列中的连接时间，可以缓解受到大量连接关闭请求时的压力。

**查看当前值**：

```shell
sysctl net.ipv4.tcp_fin_timeout
```

**临时设置值**：

```shell
sysctl -w net.ipv4.tcp_fin_timeout=30
```

**永久设置**

编辑`/etc/sysctl.conf`或`/etc/sysctl.d/syn_flood.conf`，加入

```shell
net.ipv4.tcp_fin_timeout = 30
```

执行命令：`~]# sysctl -p`

**验证设置**

```shell
[root@node1 ~]# sysctl net.ipv4.tcp_fin_timeout
net.ipv4.tcp_fin_timeout = 30
```



---



### 4. **tcp_rmem **

设置接收缓冲区的最小、默认和最大值。这对于 TCP 连接的性能和流量控制至关重要。接收缓冲区的大小决定了在数据被应用程序读取之前，TCP 协议栈可以存储多少数据。如果接收缓冲区过小，可能导致接收到的数据无法及时存储，触发丢包或性能下降。

**缓冲区过小**

- 接收缓冲区无法充分容纳数据包，可能会导致 TCP 拥塞或丢包。
- 在高延迟（如卫星通信）或高带宽（如千兆网）环境下，可能无法充分利用网络带宽。

**缓冲区过大**

- 系统资源消耗较高，特别是在大量并发连接的情况下可能导致内存耗尽。
- 如果网络质量较差，缓冲区过大会导致传输延迟增加。

**查看当前值**

```shell
[root@mirror-sv ~]# sysctl net.ipv4.tcp_rmem
net.ipv4.tcp_rmem = 4096	131072	6291456
```

`最小值4096`: 每个 TCP 连接接收缓冲区的最小大小为 4096 字节（4 KB）,即使系统内存资源不足，每个连接的缓冲区也不会小于这个值

`默认值 131072`：系统分配给每个 TCP 连接的初始接收缓冲区大小为 131072 字节（128 KB），这个值会动态调整，但初始时从此值开始分配。

`最大值 6291456`：在需要更大缓冲区的情况下（如高延迟或高带宽环境），系统会自动调整接收缓冲区大小，但不会超过 6291456 字节（6 MB），前提是 TCP 支持大窗口（启用了窗口缩放）。

**临时设置值**

```
sysctl -w net.ipv4.tcp_rmem="4096 87380 4194304"
```

**永久设置**

编辑`/etc/sysctl.conf`或`/etc/sysctl.d/syn_flood.conf`，加入

```shell
net.ipv4.tcp_rmem = 4096 262144 8388608
```

执行命令：`~]# sysctl -p`

**检查 TCP 接收缓冲区的实际使用情况**

```shell
[root@mirror-sv ~]# ss -tni
State         Recv-Q         Send-Q                     Local Address:Port                      Peer Address:Port          Process                                                                                                                    
ESTAB         0              52                       199.188.109.153:22                      103.169.216.65:54240
	 cubic wscale:8,7 rto:400 rtt:197.738/18.514 ato:40 mss:1360 pmtu:1500 rcvmss:1360 advmss:1460 cwnd:10 bytes_sent:20148 bytes_acked:20096 bytes_received:12122 segs_out:218 segs_in:293 data_segs_out:169 data_segs_in:182 send 550223bps lastsnd:8 lastrcv:8 lastack:8 pacing_rate 1100440bps delivery_rate 414568bps delivered:169 app_limited busy:19732ms unacked:1 rcv_space:14600 rcv_ssthresh:64076 minrtt:200.995 snd_wnd:65280
```

`State`：ESTAB，表示 TCP 连接已建立（Established），正在进行数据传输。

`Recv-Q`：表示内核为接收缓冲区分配的字节数，当前已收到但尚未被应用程序读取的数据量。如果 `Recv-Q` 经常接近 `tcp_rmem` 的最大值（`sysctl net.ipv4.tcp_rmem` 中的最大值），可能表明缓冲区不足。

`Send-Q`：当前发送缓冲区中尚未被对端确认的数据量，有 52 字节数据还未收到对端的 ACK。

`Local Address:Port` 和 `Peer Address:Port`：本地地址和端口：`199.188.109.153:22`，表示本地的 SSH 服务，对端地址和端口103.169.216.65:54240，表示远程客户端。

`cubic`：当前使用的 TCP 拥塞控制算法是 CUBIC，这是 Linux 默认的算法，适用于高带宽高延迟场景。

`wscale:8,7`：TCP 窗口比例因子，发送方为 8，接收方为 7。通过窗口缩放支持更大的窗口大小（大于 64 KB）。

`rto`（Retransmission Timeout）: 400 ms，重传超时时间。如果数据未被确认，TCP 会在 400 毫秒后触发重传。TCP 使用 RTT 和 RTTVar 来计算 RTO，这是决定什么时候重传丢失数据包的一个重要参数。RTO 通常基于 RTT 和 RTTVar 来估算，以便能够灵活应对网络条件的变化。如果 RTT 变得不稳定，RTTVar 会变得很大，导致 TCP 增加重传的安全时间，以避免因网络波动导致过早的重传。

`rtt`（Round-Trip Time）: 197.738 ms，是指一个数据包从发送方发送出去，到达接收方并返回的总时间。这是网络延迟的重要衡量标准，通常用毫秒（ms）来表示。。

`rttvar`（RTT 方差）: 18.514 ms，则是衡量 RTT 波动的程度。RTT 并不是固定的，它会随着网络的状态发生变化，可能因为网络负载、链路拥塞、路由变化等因素导致 RTT 的波动。RTTVar 用来度量这种变化的幅度，也就是 RTT 的波动范围。如果 RTTVar 很大，说明网络延迟变化较为剧烈，可能表示网络存在波动或拥塞的情况，TCP 会在这种情况下调整拥塞控制算法，避免过度发送数据，导致网络进一步拥塞。

`ato`（Acknowledgement Timeout）: 40 ms，ACK 的超时时间间隔。TCP 协议使用 ATO 来控制确认报文的超时时间。当发送方发送一个数据包后，它会等待接收方返回一个确认报文（ACK）。ATO 就是等待 ACK 报文的最大时间限制。

`mss`（Maximum Segment Size）: TCP 数据包的最大分段大小（不包括头部）。值为 1360，通常是根据 PMTU 计算得来。

`pmtu`（Path MTU）: 路径最大传输单元，包括 IP 和 TCP 头部，标准以太网的默认值是 1500 字节。

`rcvmss` 和 `advmss`：rcvmss是接收方可以接受的最大分段大小，advmss是建议使用的 MSS 大小。

`cwnd`（拥塞窗口） ：当前拥塞窗口大小，以 MSS 为单位。值为 10：发送方在未收到 ACK 的情况下最多可发送 10 个 MSS 的数据。

`snd_wnd`（发送窗口）: 发送方根据接收方通告窗口计算出的可用发送窗口大小。

`rcv_space`（接收缓冲区剩余空间）: 接收缓冲区当前未使用的空间。

`rcv_ssthresh`（接收慢启动阈值）: 接收窗口在慢启动阶段的阈值。

`bytes_sent`: 当前连接已发送的总字节数

`bytes_acked`: 发送的数据中已被对端确认的总字节数。未确认数据：`20148 - 20096 = 52`，与 `Send-Q` 对应。

`bytes_received`: 12122，从对端接收到的总字节数。

`segs_out` 和 `segs_in`：segs_out 218，表示总共发送了 218 个 TCP 数据段，segs_in 293表示总共接收了 293 个 TCP 数据段。

`data_segs_out` 和 `data_segs_in`：data_segs_out 169 表示实际发送的数据段数，data_segs_in 182，表示实际接收到的数据段数。

`unacked`: 发送缓冲区中未被确认的数据包数。

`send`: 550223 bps ，当前的发送速率（实际数据吞吐量）。

`pacing_rate`: 1100440 bps，发送数据时的限速（由拥塞控制算法计算）。

`delivery_rate`: 414568 bps，实际数据交付速率。

`lastsnd`, `lastrcv`, `lastack`：lastsnd  8 ms 上次发送数据距今的时间。lastrcv 8 ms，上次接收数据距今的时间。lastack 8 ms，上次接收 ACK 距今的时间。

`delivered`: 169  TCP 连接已成功交付的数据包总数。

`app_limited`：值为 1，表示应用程序限制，即 TCP 连接的数据传输速率受到应用程序处理能力的限制，而不是网络带宽或系统资源的限制。

`busy`: 19732 ms，TCP 连接活跃传输的时间总计为 19732 毫秒。

接收缓冲区不足可能导致丢包。使用 `ifconfig` 或 `ip -s link` 查看网络接口的丢包统计。

```
[root@node1 ~]# ip -s link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    RX:  bytes packets errors dropped  missed   mcast           
    4402348415 7769941      0       0       0       0 
    TX:  bytes packets errors dropped carrier collsns           
    4402348415 7769941      0       0       0       0 
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether b0:09:c0:00:28:09 brd ff:ff:ff:ff:ff:ff
    RX:     bytes     packets errors dropped  missed   mcast           
    1596790887209 14874116073      0       0       0       0 
    TX:     bytes     packets errors dropped carrier collsns           
       9621789533    30109936      0       0       0       0 
    altname enp0s17
    altname ens17
```

dropped： 表示因缓冲区溢出导致的丢包数。如果此值增长过快，可能是接收缓冲区不足的表现。



---



### 5. **tcp_wmem**

`tcp_wmem` 是 Linux 内核中的 TCP 参数，用于配置 **发送缓冲区** 的大小范围。它决定了 TCP 连接的发送缓冲区在不同条件下的分配策略。

**查看当前设置**

```
~]# sysctl net.ipv4.tcp_wmem
net.ipv4.tcp_wmem = 4096	16384	4194304
```

- 4096（最小值）：每个 TCP 连接的发送缓冲区的最小值，单位是字节（Bytes），即使系统内存紧张，也会为每个 TCP 连接预留至少 4 KB 的发送缓冲区。
- 16384（默认值）：TCP 发送缓冲区的默认大小，单位是字节，在没有特殊需求的情况下，TCP 连接会尝试使用 16 KB 的发送缓冲区。
- 4194304（最大值）：每个 TCP 连接的发送缓冲区的最大值，单位是字节。在高带宽、高延迟的网络中，如果内核自动调整需要更大的发送缓冲区，则可以扩展到最大约 4 MB。

使用ss -tni可以看到当前发送缓冲区的详情，其中Send-Q对应的值表示待发送的数据以及已发送但未被对方确认的数据，如果这个值接近或超过缓冲区的限制，就会发生瓶颈。可能意味着网络延迟过大（RTT 高）、数据发送速度快于对方确认的速度、当前发送缓冲区配置不足以适应实际的网络条件。

**临时设置**

使用 `sysctl` 命令：

```
sysctl -w net.ipv4.tcp_wmem="4096 65536 8388608"
```

**永久设置**

在 `/etc/sysctl.conf` 中添加以下行：

```
net.ipv4.tcp_wmem = 4096 65536 8388608
```

执行命令：`~]# sysctl -p`



---



### 6. **tcp_moderate_rcvbuf**

在 Linux 操作系统中，TCP 缓冲区是处理网络数据传输的关键组件。`net.ipv4.tcp_moderate_rcvbuf` 是一个内核选项，用于动态调整 TCP 的接收缓冲区和发送缓冲区大小，以便优化网络性能。默认情况下，这些缓冲区大小是固定的。启用 `tcp_moderate_rcvbuf` 之后，将动态调整 `tcp_rmem` 和 `tcp_wmem` 的值。可能会增加内存使用，因为动态调整的缓冲区会根据网络需求调整大小。如果网络负载非常高，并且内存资源有限，可能会导致系统负载增加，特别是在极端情况或大量高流量连接时。

**临时配置**

```
sysctl -w net.ipv4.tcp_moderate_rcvbuf=1
```

**永久配置**

在 `/etc/sysctl.conf` 中添加以下行：

```
net.ipv4.tcp_moderate_rcvbuf=1
```

执行命令：`~]# sysctl -p`



---



### 7. **tcp_keepalive_time、tcp_keepalive_intvl、 tcp_keepalive_probes**

在 Linux 系统中，TCP 保持连接功能（TCP Keepalive）用于保持长时间未使用的连接，防止连接由于长时间闲置而断开。`tcp_keepalive_time`、`tcp_keepalive_intvl` 和 `tcp_keepalive_probes` 是控制 TCP 保持连接的三个关键参数。

- **`tcp_keepalive_time`**：如果在此时间内没有数据传输或活动连接，则TCP会尝试发送保持连接探测包来检测远端是否仍在线。默认7200 秒
- **`tcp_keepalive_intvl`**：指定在 TCP Keepalive 探测中，每个探测之间的时间间隔（以秒为单位）。
- **`tcp_keepalive_probes`**：指定发送的保持连接探测的最大次数（重试次数），默认9 次。如果所有探测都未收到应答，则视为远程主机不再响应

**查看当前值**

```
sysctl net.ipv4.tcp_keepalive_time
sysctl net.ipv4.tcp_keepalive_intvl
sysctl net.ipv4.tcp_keepalive_probes
```

**临时设置值**

```
sysctl -w net.ipv4.tcp_keepalive_time=7200
sysctl -w net.ipv4.tcp_keepalive_intvl=75
sysctl -w net.ipv4.tcp_keepalive_probes=9
```

**永久配置**

在 `/etc/sysctl.conf` 中添加以下行：

```
net.ipv4.tcp_keepalive_time = 3600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 5
```

执行命令：`~]# sysctl -p`



### 8. **tcp_abort_on_overflow**

当 TCP 堆栈接收到的数据包超过接收缓冲区能力时，是否直接中止连接（即立即断开连接），而不是等待缓冲区空间释放。启用该功能有助于减少恶意连接请求对系统资源的消耗，尤其是在攻击期间。

**查看当前值**：

```
sysctl net.ipv4.tcp_abort_on_overflow
```

**临时设置**

- 取值1：启用，如果接收缓冲区（接收队列）的容量已满，系统会立即关闭该连接，而不是等待缓冲区释放空间后重新接收数据。
- 取值0：禁用 ，如果接收缓冲区已满，系统会先进行缓冲区扩展尝试，直到有足够的空间接受数据，或直到达到一定的超时，然后才决定是否关闭连接。

```
sysctl -w net.ipv4.tcp_abort_on_overflow=1
```

**永久配置**

在 `/etc/sysctl.conf` 中添加以下行：

```shell
net.ipv4.tcp_abort_on_overflow = 1
```

执行命令：`~]# sysctl -p`



---



### 9. 使用防火墙对链接数限制

**iptables**

- 限制每个 IP 同时连接数不超过 10：

```shell
iptables -A INPUT -p tcp --syn -i eth0 -m connlimit --connlimit-above 10 -j REJECT
```

- 限制每个 IP 每秒最大连接数为 1，突发次数为 5：

```shell
iptables -A INPUT -p tcp --syn --dport 80,443 -i eth0 -m hashlimit --hashlimit-name ip_limit --hashlimit 1/s --hashlimit-burst 5 -j ACCEPT
```



**firewalld**

- 限制每个 IP 同时连接数不超过 10：

```shell
firewall-cmd --permanent --zone=public --add-rich-rule='rule family=ipv4 protocol=tcp connection-limit=10 reject'
firewall-cmd --reload
```

- 限制每个 IP 每秒最大连接数为 1，突发次数为 5：

```shell
firewalld-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="80" protocol="tcp" accept limit value="1/s,burst=5"' 
firewalld-cmd --permanent --zone=public --add-rich-rule='rule family="ipv4" source address="0.0.0.0/0" port port="443" protocol="tcp" accept limit value="1/s,burst=5"' 
firewalld-cmd --reload
```



**nft**

- 限制每个 IP 同时连接数不超过 10：

```shell
nft add table ip filter
nft add chain ip filter input { type filter hook input priority 0; }
nft add rule ip filter input tcp flags syn ct state new,established limit rate 10 connbytes 0 accept
nft add rule ip filter input reject
```

- 限制每个 IP 每秒最大连接数为 1，突发次数为 5：

```shell
nft add table ip filter
nft add chain ip filter input { type filter hook input priority 0; }
nft add rule ip filter input tcp flags syn ct state new,established ip daddr .80,443 limit rate 1/s burst 5 accept
```

